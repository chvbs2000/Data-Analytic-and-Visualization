---
title: 'Project 1: Explore and Prepare Data'
subtitle: |-
  GT Account: kchen360 - Kai-yu Chen - CSE6242 - Data and Visual Analytics - Spring 2017
  Due: Sunday, March 5, 2017 at 11:59 PM UTC-12:00 on T-Square
output:
  html_document: default
  html_notebook: default
  pdf_document: default
---

_Note: This project involves getting data ready for analysis and doing some preliminary investigations. Project 2 will involve modeling and predictions, and will be released at a later date. Both projects will have equal weightage towards your grade._

# Data

In this project, you will explore a dataset that contains information about movies, including ratings, budget, gross revenue and other attributes. It was prepared by Dr. Guy Lebanon, and here is his description of the dataset:

> The file [`movies_merged`](https://s3.amazonaws.com/content.udacity-data.com/courses/gt-cs6242/project/movies_merged) contains a dataframe with the same name that has 40K rows and 39 columns. Each row represents a movie title and each column represents a descriptor such as `Title`, `Actors`, and `Budget`. I collected the data by querying IMDb???s API (see [www.omdbapi.com](http://www.omdbapi.com/)) and joining it with a separate dataset of movie budgets and gross earnings (unknown to you). The join key was the movie title. This data is available for personal use, but IMDb???s terms of service do not allow it to be used for commercial purposes or for creating a competing repository.

# Objective

Your goal is to investigate the relationship between the movie descriptors and the box office success of movies, as represented by the variable `Gross`. This task is extremely important as it can help a studio decide which titles to fund for production, how much to bid on produced movies, when to release a title, how much to invest in marketing and PR, etc. This information is most useful before a title is released, but it is still very valuable after the movie is already released to the public (for example it can affect additional marketing spend or how much a studio should negotiate with on-demand streaming companies for ???second window??? streaming rights).

# Instructions
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. Open this file in RStudio to get started.

When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
x = 1:10
print(x^2)
```

Plots appear inline too:
```{r}
plot(x, x^2, 'o')
```

```{r}

```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file).

Please complete the tasks below and submit this R Markdown file (as **pr1.Rmd**) as well as a PDF export of it (as **pr1.pdf**). Both should contain all the code, output, plots and written responses for each task.

# Setup

## Load data

Make sure you've downloaded the [`movies_merged`](https://s3.amazonaws.com/content.udacity-data.com/courses/gt-cs6242/project/movies_merged) file and it is in the current working directory. Now load it into memory:

```{r}
load('~/movies_merged')
```

This creates an object of the same name (`movies_merged`). For convenience, you can copy it to `df` and start using it:

```{r}
df = movies_merged
cat("Dataset has", dim(df)[1], "rows and", dim(df)[2], "columns", end="\n", file="")
colnames(df)
```

## Load R packages

Load any R packages that you will need to use. You can come back to this chunk, edit it and re-run to load any additional packages later.

```{r, warning=FALSE}
library(ggplot2)
library(GGally)
library(grid)
library(gridExtra)
library(corrplot)
library(dplyr)
library(knitr)
library(stringr)
```

If you are loading any non-standard packages (ones that have not been discussed in class or explicitly allowed for this project), please mention them below. Include any special instructions if they cannot be installed using the regular `install.packages('<pkg name>')` command.

**Non-standard packages used**: 
```{r, warning=FALSE}
#grid graphic 
install.packages("grid")
#miscellaneous functions for grid graphic 
install.packages("gridExtra")
#plot correlat
install.packages("corrplot")
#data manipulation
install.packages("dplyr")
#dynamic report
install.packages("knitr")
#string process
install.packages("stringr")

```

# Tasks

Each task below is worth **10** points, and is meant to be performed sequentially, i.e. do step 2 after you have processed the data as described in step 1. Total points: **100**

Complete each task by implementing code chunks as described by `TODO` comments, and by responding to questions ("**Q**:") with written answers ("**A**:"). If you are unable to find a meaningful or strong relationship in any of the cases when requested, explain why not by referring to appropriate plots/statistics.

It is OK to handle missing values below by omission, but please omit as little as possible. It is worthwhile to invest in reusable and clear code as you may need to use it or modify it in project 2.

## Note: The missing value in the dataset is MCAR, the missing value will be handled according to the question

## 1. Remove non-movie rows

The variable `Type` captures whether the row is a movie, a TV series, or a game. Remove all rows from `df` that do not correspond to movies.

# TODO: Remove all rows from df that do not correspond to movies
```{r}
mydata = df
movie <- mydata[mydata$Type=="movie",]

```

**Q**: How many rows are left after removal? _Enter your response below._

**A**: After removal of non-movies rows, there are 40000 rows remaining. movie data correspond to df.  

## 2. Process `Runtime` column

The variable `Runtime` represents the length of the title as a string. Write R code to convert it to a numeric value (in minutes) and replace `df$Runtime` with the new numeric column.

```{r, warning=FALSE}

movie<-as.data.frame(movie)

#convert hours to minutes
v<-movie$Runtime
l <- length(v)
runtime <-character(40000)
for (i in 1:l){
  if (grepl("h",v[i])==TRUE){
    v[i] <- substr(v[i],5,6)
    v[i] <- as.numeric(as.character(v[i]))+60
  }else{
    regexp <- "[[:digit:]]+"
    v[i]<-str_extract(v[i], regexp)
  }
  runtime[i] <- v[i]
}
runtime<-as.numeric(as.character(runtime))
print(head(runtime))
```

Mechanism of converting Runtime into minutes(numeric): Search the cells that has "h" (hour) in the Runtime column, extract the number in the cell and remove the number that is not in the first position. First number times 60 to convert hour to minutes, followed by adding back removal numbers. At the end, a character vector was converted to a numeric vector. 

# Replace df$Runtime with a numeric column containing the runtime in minutes
```{r}
movie$Runtime<-runtime

```

Now investigate the distribution of `Runtime` values and how it changes over years (variable `Year`, which you can bucket into decades) and in relation to the budget (variable `Budget`). Include any plots that illustrate.

# TODO: Investigate the distribution of Runtime values and how it varies by Year and Budget
# Examine Runtime distribution 
```{r, warning=FALSE}
#Investigate boundary of runtime
summary(movie$Runtime)

ggplot(movie, aes(x=Runtime)) + 
  geom_histogram(bins=400) + 
  labs(x = "Movie Run Time", y="Frequency", title = "Movie RunTime Histogram")
```
The data Runtime heavily right skewed, representing there are outliers with extreme long runtime.On average, most movies have runtime ranging from 70-100 minutes. There are many movies with shorter runtime (<50 minutes) and represneted by the left peak.    

#Remove Runtime outliers
```{r, warning=FALSE}
data2 <-movie[!is.na(movie$Runtime),]
data2 <- subset(data2,!(data2$Runtime > quantile(data2$Runtime, probs=c(.01, .99))[2] | data2$Runtime < quantile(data2$Runtime, probs=c(.01, .91))[1])) 

```

#Examine Runtime and Year
```{r, warning=FALSE}
#bucket Year into as a decade unit
data2$DecadeYear = cut(data2$Year, seq(1880, 2020, by=10), dig.lab=4)
summary_yr = data2 %>% group_by(DecadeYear) %>% 
  summarize(
    freq = length(Runtime),
    min = min(Runtime, na.rm=TRUE),
    q1 = quantile(Runtime, prob=0.25, na.rm=TRUE),
    mean = mean(Runtime, na.rm=TRUE),
    median = quantile(Runtime, prob=0.50, na.rm=TRUE),
    q3 = quantile(Runtime, prob=0.75, na.rm=TRUE),
    max = max(Runtime, na.rm=TRUE),
    std = sd(Runtime, na.rm=TRUE)
  )
summary_yr = data.frame(summary_yr)
kable(summary_yr)

ggplot(data2, aes(x=DecadeYear, y=Runtime, fill=DecadeYear)) + 
  geom_boxplot() + 
  labs(x = " Year 10-Year Interval", y="Movie Run Time") +
  theme(axis.text.x = element_text(angle = 90)) +
  coord_flip()
```
Boxplot is used to investigate quantiles information, median, and outliers in Year with 10-year as a unit. As the result, there is a increasing trend in runtime along the years. There is also a increasing trend in number of outliers from 1950 to 1990.  


#scatterplot of movie run time and year
```{r, warning=FALSE}
ggplot(data2, aes(x=DecadeYear, y=Runtime, fill=DecadeYear)) + 
  geom_point() + 
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = " Year 10-Year Interval", y="Movie Run Time")
```

From the scatterplot above, there's a trend that movie runtime span greatly starts from 1910 and over the years. 

#Investigate the relationship of Runtime and Budget
```{r, warning=FALSE}
#There are 35442 missing values in Budget column in movie data
summary(movie$Budget)

#scatter plot between Budget and Runtime with smoothed line
qplot(Runtime, Budget, data = data2, size = I(1.2)) +
stat_smooth(color = "red", size = I(2), se = F)+xlab("Runtime")+ylab("Budget")

```

#Scatter plot between Budget and Runtime with smoothed line after removing Budget values and runtime outliers
```{r, warning=FALSE}
#remove Budget missing value
data2 = data2[!is.na(data2$Budget),]

qplot(Runtime, Budget, data = data2, size = I(1.2)) +
stat_smooth(color = "red", size = I(2), se = F)+xlab("Runtime")+ylab("Budget")
```

**Q**: Comment on the distribution as well as relationships. Are there any patterns or trends that you can observe?

**A**: Runtime is heavily right skewed due to some movies with extreme longer runtime. There are some movies with runtime time less than 50 minutes. There is a trend of increases in movie runtime along years, and variaiton in runtime is huge since 1910, implying diversities in movie runtime. The budget has around 35000 missing value. When investigating the relationship between movie runtime and movie budget, situations of considering with Budget missing value and without Budget missing value are handled. The result shows that there's not much difference in the two situations. Budget decreases along the runtime and increases again after runtime exceed 75 minutes. The variation of budget is big at a runtime approximately range from  75 minutes to 135 minutes. There are some movies with runtime exceed 150 minutes and their budget variations is high as well. 

## 3. Encode `Genre` column

The column `Genre` represents a list of genres associated with the movie in a string format. Write code to parse each text string into a binary vector with 1s representing the presence of a genre and 0s the absence, and add it to the dataframe as additional columns. Then remove the original `Genre` column.

For example, if there are a total of 3 genres: Drama, Comedy, and Action, a movie that is both Action and Comedy should be represented by a binary vector <0, 1, 1>. Note that you need to first compile a dictionary of all possible genres and then figure out which movie has which genres (you can use the R `tm` package to create the dictionary).

#Directionary of all possible genres
```{r, warning=FALSE}
#unlist genre
type_genre = unlist(strsplit(movie$Genre, ','))
# Change to lower case
type_genre = tolower(type_genre)
# Trim whitespace
type_genre = gsub(' ', '', type_genre)
# Remove punctuation
type_genre = gsub("[[:punct:]]", "", type_genre)
# Remove duplicate rows/elements
type_genre = unique(type_genre)
# List all the unique genre
print(type_genre)
```
# TODO: Replace Genre with a collection of binary columns
```{r, warning=FALSE}
# change Genre column to lower case
movie$Revised_Genre = tolower(movie$Genre)
# trim whitespace
movie$Revised_Genre = gsub(" ", "", movie$Revised_Genre)
# replace comma by space
movie$Revised_Genre = gsub(",", " ", movie$Revised_Genre)
# remove punctuation
movie$Revised_Genre = gsub("[[:punct:]]", "", movie$Revised_Genre)
# Create binary vector for each type of genre
genre_matrix = NULL
for (i in 1:length(type_genre)){
  g = type_genre[i]
  binary = as.numeric(grepl(paste('\\b',g,'\\b', sep=""), movie$Revised_Genre))
  genre_matrix = cbind(genre_matrix, binary)
}
#dataframe binary genre matrix
genre_final = data.frame(genre_matrix)
colnames(genre_final) = paste("Genre_", type_genre, sep="")
#combine binary genre matrix with original movie data and replace original Genre column
movie$Genre = NULL
movie$Revised_Genre = NULL
movie = cbind(movie, genre_final)
```

# TODO: Select movies from top 10 most common genres and plot their relative proportions
```{r, warning=FALSE}
summary_gen = data.frame(genre=names(genre_final),num_movie=colSums(genre_final))
summary_gen$genre = gsub("Genre_", "", summary_gen$genre)
summary_gen$per_movie = summary_gen$num_movie / nrow(movie)
summary_gen = summary_gen[order(-summary_gen$per_movie),]
summary_gen$rank = seq(1:nrow(summary_gen))
#summary_gen$rank2 = sprintf("%02d", summary_gen$rank)
row.names(summary_gen) = NULL

#Plot the relative proportions of movies having the top 10 most common genres.
genrerank_top10<-summary_gen[1:10,]

ggplot(genrerank_top10, aes(x=reorder(genre, per_movie), y=per_movie)) + 
  geom_bar(stat="identity", fill="light blue") +
  geom_text(aes(label=round(per_movie*100,1))) + 
  scale_y_continuous(labels = scales::percent) +
  coord_flip() +
  labs(x="Movies' Genres", y="Proportion of Movies")

```
Proportion in each movie category is calculate by sum of the number in the movie category divided by total number of movies. As a result, drama movies has the highest proportions in the movie. 

# Examine how the distribution of `Runtime` changes across genres for the top 10 most common genres.
# TODO: Plot Runtime distribution for top 10 most common genres
```{r, warning=FALSE}
genre = summary_gen$genre
newGenre = NULL
for (g in genre){
  # Filter dataset to include 1 if genre present in the record
  genre_data = movie[movie[[paste("Genre_",g,sep="")]]==1,]
  genre_data = genre_data[,c("Year","Runtime")]
  genre_data$genre = g
  newGenre = rbind(newGenre, genre_data)
}

newGenre = merge(newGenre, summary_gen[,c("genre","rank")], by="genre")
top_10_list = c("drama","comedy","short","romance","action","crime","thriller","documentary","adventure","animation")
#data with top 10 genre 
top_10 = newGenre[newGenre$genre %in% top_10_list,]
#remove runtime NA
top_10 = top_10[!is.na(top_10$Runtime), ]
#plot runtime according to top 10 genres
ggplot(top_10, aes(x=reorder(genre, -rank), y=Runtime,fill=genre))+ 
  geom_boxplot()+
  coord_flip()+
  labs(x="Genre", y="Runtime", title="Runtime measurement in top 10 Genre")

```

**Q**: Describe the interesting relationship(s) you observe. Are there any expected or unexpected trends that are evident?

**A**: The most common genre is drama (39.6%). There is not much differences in median runtime (~100 minutes) among top 10 common genres except short movies, animation movies and documentary movies. It is surprised that animation movies have such a short average runtime. Documentary movie has most variation and spanned in runtime compared to other category of movies. Short movies have least outliers and least sapnned, indicating that short movies are closely distributed around mean value.

## 4. Eliminate mismatched rows

The dataframe was put together by merging two different sources of data and it is possible that the merging process was inaccurate in some cases (the merge was done based on movie title, but there are cases of different movies with the same title). The first source???s release time was represented by the column `Year` (numeric representation of the year) and the second by the column `Released` (string representation of release date).

Find and remove all rows where you suspect a merge error occurred based on a mismatch between these two variables. To make sure subsequent analysis and modeling work well, avoid removing more than 10% of the rows that have a `Gross` value present.

# TODO: Remove rows with Released-Year mismatch
```{r, warning=FALSE}
summary(movie$Year)
#create a column specify released year
movie$Released = as.Date(movie$Released, format="%Y-%m-%d")
movie$YearReleased = as.numeric(format(movie$Released, "%Y"))

#method 1
#create a column to check if Year and Released Year matches
movie$release1 = ifelse(movie$Year == movie$YearReleased, TRUE, FALSE)
summary(as.factor(movie$release1))

#method 2
#create a column to check if precious/ future 1 Year matches to Released Year
movie$release2 = ifelse((
  (movie$Year) == movie$YearReleased |
  (movie$Year+1) == movie$YearReleased |
  (movie$Year-1) == movie$YearReleased),
  TRUE,FALSE)

# number of Gross value without NA
gross = length(movie$Gross[!is.na(movie$Gross)])

# Filter out mismatch of Year and Released Year by method 1
subdata1 = subset(movie, release1==TRUE)
nrow(subdata1)

# Gross derived from method 1
gross1 = length(subdata1$Gross[!is.na(subdata1$Gross)])
miss_gross1 = gross-gross1
print((miss_gross1/gross)*100)

# Filter out mismatch Year and Released Year by method
subdata2 = subset(movie, release2==TRUE)
nrow(subdata2)

# Gross derived from method 2
gross2 = length(subdata2$Gross[!is.na(subdata2$Gross)])
miss_gross2 = gross-gross2
print((miss_gross2/gross)*100)

```

**Q**: What is your precise removal logic and how many rows did you end up removing?

**A**: YearReleased column was created to store released year dervied from released date for each case. Method 1 was applied to check if the value in YearReleased exactly mateches to Year. Method 2 was applied to check if the value in YearReleased matches to Year+1 / Year-1, indicating more error acceptance in year mismatch. A valid Gross value means a non missing value. As a result, When applying method 1, there will be around 18% rows removal that have valid Gross values, whereas when applying method 2, there will be only around 3% rows removal that have valid Gross values. Therefore, it is more acceptable to apply method 2 to lower merge errors at consideration of not removing more than 10% rows that have valid Gross values. So there would be 136 rows removed from the data at the end.  

## 5. Explore `Gross` revenue

For the commercial success of a movie, production houses want to maximize Gross revenue. Investigate if Gross revenue is related to Budget, Runtime or Genre in any way.

Note: To get a meaningful relationship, you may have to partition the movies into subsets such as short vs. long duration, or by genre, etc.


```{r, warning=FALSE}
# Investigate if Gross Revenue is related to Budget

#categorize movie according to genre
#create a subset dataframe consists of Genre, Runtime, Budget, Gross
data5 = NULL
for (g in genre){
  # Filter dataset to include 1 if genre present in the record
  data = movie[movie[[paste("Genre_",g,sep="")]]==1,]
  data = data[,c("Gross","Runtime","Budget")]
  data$genre = g
  data5 = rbind(data5, data)
}

# omit missing value 
movieNoNa5 = na.omit(data5)
qplot(Budget,Gross,data=movieNoNa5,size=I(1))+stat_smooth(color="orange",size=I(2),se=F)

#Check if Gross revenue is related to Budget by Genre
ggplot(movieNoNa5,aes(Budget,Gross))+geom_point()+facet_wrap(~genre)+theme(axis.text.x = element_text(angle = -90, vjust = 1, hjust = 0))
```


# Investigate if Gross Revenue is related to Runtime
```{r, warning = FALSE}
# Investigate if Gross Revenue is related to Runtime
qplot(Runtime,Gross,data=movieNoNa5,size=I(1))+stat_smooth(color="red",size=I(2))
```


#Check if Gross revenue is related to Runtime by Genre
```{r, warning = FALSE}
ggplot(movieNoNa5,aes(Runtime,Gross))+geom_point()+facet_wrap(~genre)+theme(axis.text.x = element_text(angle = -90, vjust = 1, hjust = 0))
```


# Investigate if Gross Revenue is related to Genre
```{r, warning=FALSE}
ggplot(movieNoNa5, aes(x=reorder(genre,Gross), y=Gross)) +
  geom_bar(stat="identity", fill="#CC6666") +
  coord_flip() +
  labs(x="Genre", y="Gross",
       title="Gross Revenue by Genre")

```


**Q**: Did you find any observable relationships or combinations of Budget/Runtime/Genre that result in high Gross revenue? If you divided the movies into different subsets, you may get different answers for them - point out interesting ones.

**A**: There are slightly obvious positive relationship between Gross revenue and Budget in action movies, adventure movies, amination movies, and fantacy movies. Gross revenue varies in low to medium range of budget in  drama, and family movies. Most movies have lower budget and lower gross revenue in the categories of adult, biography, documentary, filmnoir, history, horror, music, musical, mistry, new,  short, sport, and war movies.  there are some outliers that achieve relatively high gross revenue associated with high budget in action, adventure, fantacy, and fantacy movies. There are also some movies achieve relatively high gross revenue with medium budget expense in the category of crime, drama, and remance. Some western movies spent high budget but achieve lower gross revenue. 

There is a positive relationship between gross revenue and runtime at the range of 50 minutes to 150 minutes. The gross revenue increases and dereases along the increase in runtime. There is a relatively high variation in gross revenue between the runtime range of 80 mintes to 150 minutes. There are some movies with high gross revenue at medium range of runtime. Noted there are also some movies with high runtime but low gross revenue. 

It is intersting to see if gross revenue is associate with runtime in each genre. As the result, the gross revenue variaiton is high in the mean range of runtime in action, adventure, animation, comedy, family, scifi, and thriller movies. Some movie achieve low gross revenue regardless of the length of runtime in the genre of documentary, filmnoir, history, music, musical, new, sport, and war. 

Overall all, it is hard to determine a significant positive relationship between gross revenue and runtime in each genre. 

Based on the boxplots, adventure movies achieve the highest gross revenue compared to other genre, and action movies, comedy movies, and drama movies also have high gross revenue. The gross revenue is very low in western movies, musical movies, sport movies, war movies, and documentary movies. Short movies and adult movies barely have gross revenues. The result can be used to investigate the preference in genral populations. 

# TODO: Investigate if Gross Revenue is related to Release Month
```{r, warning = FALSE}
#add a column specify release month
subdata2$ReleasedMonth = format(subdata2$Released, "%m")
# omit missing value in gross revenue
subdata2 = subdata2[!is.na(subdata2$Gross),]
ggplot(subdata2, aes(x=ReleasedMonth, y=Gross)) + 
  geom_boxplot() + 
  labs(x="Month of Released", y="Gross Revenue",
       title="Gross Revenue by Released Month")

```

Based on the boxplots above, it seems that summer period (May - July) has overall higher average gross revenue as well as winter period (November - December). The variation of gross revenue is relatively large in these months. The observation could be explained by the time of summer vacation and winter holiday seasons. 

## 6. Process `Awards` column

The variable `Awards` describes nominations and awards in text format. Convert it to 2 numeric columns, the first capturing the number of wins, and the second capturing nominations. Replace the `Awards` column with these new columns, and then study the relationship of `Gross` revenue with respect to them.

Note that the format of the `Awards` column is not standard; you may have to use regular expressions to find the relevant values. Try your best to process them, and you may leave the ones that don't have enough information as NAs or set them to 0s.

#Convert Awards to 2 numeric columns: wins and nominations
```{r, warning = FALSE}
award = movie$Awards
# convert string to lower case
s = tolower(award)

#initialize vector
win_vector = NULL
nomination_vector = NULL

for (i in 1:length(s)){

  #extract first substring
  string1 = sapply(strsplit(s[i],"[.]"), `[`, 1)
  if (grepl("nominate",string1) == TRUE){
    nominate1 = string1
    #extract number of special nominations
    nominate1 = str_extract(nominate1,"[[:digit:]]+")
    # convert to numeric
    nominate1 = as.numeric(nominate1)
  }else if(grepl("won",string1) == TRUE){
    win1 = string1
    #extract number of special wins
    win1 = str_extract(win1,"[[:digit:]]+")
    win1 = as.numeric(win1)
  }else{
    reg1 = regexpr("[[:digit:]]+.win", string1,perl=TRUE)
    win1 = regmatches(string1,reg1)
    #return 0 if missing value
    win1 = ifelse(!identical(win1,character(0)),win1,"0")
    win1 = str_extract(win1,"[[:digit:]]+")
    win1 = as.numeric(win1)
    
    reg2 = regexpr("[[:digit:]]+.nomination", string1, perl = TRUE)
    nominate1 = regmatches(string1,reg2)
    nominate1 = ifelse(!identical(nominate1,character(0)),nominate1,"0")
    nominate1 = str_extract(nominate1,"[[:digit:]]+")
    nominate1 = as.numeric(nominate1)
  }
  
  #extract second substring
  string2 = sapply(strsplit(s[i],"[.]"), `[`, 2)
  # search patterns that have "win" and "nominations"
  if (grepl("win",string2) == TRUE | grepl("nomination",string2) == TRUE){
    reg3 = regexpr("[[:digit:]]+.win", string2,perl=TRUE)
    win2 = regmatches(string2,reg3)
    win2 = ifelse(!identical(win2,character(0)),win2,"0")
    win2 = str_extract(win2,"[[:digit:]]+")
    win2 = as.numeric(win2)
  
    reg4 = regexpr("[[:digit:]]+.nomination", string2, perl = TRUE)
    nominate2 = regmatches(string2,reg4)
    nominate2 = ifelse(!identical(nominate2,character(0)),nominate2,"0")
    nominate2 = str_extract(nominate2,"[[:digit:]]+")
    nominate2 = as.numeric(nominate2)
  }else{
    #return 0 if missing value
    win2 = 0
    nominate2 = 0
  }
  
  #add up total wins and nominations
  win_total = win1+win2
  nominate_total = nominate1 + nominate2
  
  #combine number of wins/nominations into the vectors
  win_vector = c(win_vector,win_total)
  nomination_vector = c(nomination_vector,nominate_total)  
}

  
```

#Replace Awards column by Wins and Nominations numeric columns
```{r, warning = FALSE}
movie$Awards = NULL
movie$Wins = win_vector
movie$Nominations = nomination_vector

```

#Number of rows that have valid wins
```{r, warning = FALSE}
number_valid_win <- length(movie$Wins[movie$Wins>=1])
print(number_valid_win)
```

#Number of rows that have valid nominations
```{r, warning = FALSE}
number_valid_nominate <- length(movie$Wins[movie$Nominations>=1])
print(number_valid_nominate)
```


**Q**: How did you construct your conversion mechanism? How many rows had valid/non-zero wins or nominations?

**A**: I split the string into two substring by ".",and searched for key patterns of "nominate","won","nomination","win" in the first substring. Noted that if the first substring consists "nominate" or "won", it means there were specific awards, and the second substring would consist "win"/"nomination". In each iteration, total number of wins were extracted, counted, and added into a vector. Total number of nominations were extracted, counted, and added in to a vector as well. Notice that if there was missing value, it will be stored as 0. There were 10998 rows that have valid wins and 11427 rows that have valid nominations.

#Plot Gross revenue against Wins
```{r, warning = FALSE}
# new subset
data6 <- movie[,c("Gross","Wins","Nominations")]
# omit rows with missing Gross Revenue
data6NoNa <- data6[!is.na(data6$Gross),] 
# remove Gross Revenue outliers
newdata6 <- subset(data6NoNa,!(Gross > quantile(Gross, probs=c(.01, .99))[2] | Gross < quantile(Gross, probs=c(.01, .91))[1]) ) 

qplot(log(Wins), Gross[], data = newdata6, size = I(1.2), main="Gross Revenue vs Number of Wins") +
stat_smooth(color = "orange", size = I(2), se = F)+xlab("Log Wins")+ylab("Gross Revenue")


```

#Plot Gross revenue against Nominations
```{r, warning=FALSE}
ggplot(newdata6,aes(log(Nominations),Gross))+geom_point()+geom_smooth()+labs(title="Gross Revenue vs Number of Nominations",x="Log of Number of Nominations",y="Gross Revenue")
```

**Q**: How does the gross revenue vary by number of awards won and nominations received?

**A**: Both Wins and Nominations were transformed by log transformation before analysis. Gross revenue vary greatly at low logarithm number of awards wins, yet there's a slightly positive relationship between logarithm number of awards wins and gross revenue as logarithm number of awards increase. Similarly, there's slightly positive relationship between gross revenue and logarithm number of award nominations. Gross revenue increases as number of nomination increases. Yet gross revenue slightly start to flucuate when logarithm number of nomination larger then 4. There was high variation in gross revenue at high award nominations. It is hard to see a specific pattern of gross revenue associated at high number of nominations.

## 7. Movie ratings from IMDb and Rotten Tomatoes

There are several variables that describe ratings, including IMDb ratings (`imdbRating` represents average user ratings and `imdbVotes` represents the number of user ratings), and multiple Rotten Tomatoes ratings (represented by several variables pre-fixed by `tomato`). Read up on such ratings on the web (for example [rottentomatoes.com/about](https://www.rottentomatoes.com/about) and [ www.imdb.com/help/show_leaf?votestopfaq](http:// www.imdb.com/help/show_leaf?votestopfaq)).

#Investigate the pairwise relationships between these different descriptors using graphs.
# TODO: Illustrate how ratings from IMDb and Rotten Tomatoes are related
```{r,warning=FALSE, echo=FALSE}

rating = c("imdbRating","imdbVotes", "tomatoMeter","tomatoRating",
               "tomatoReviews","tomatoFresh","tomatoRotten","tomatoUserMeter",
               "tomatoUserRating","tomatoUserReviews")

#combination of 2 of the rating
rating_comb = combn(rating, 2)

corr_vector = NULL
pairwise_plot = NULL
for (i in 1:ncol(rating_comb)){
  rating1 = rating_comb[1,i]
  rating2 = rating_comb[2,i]
  corr = round(cor(movie[[rating1]], movie[[rating2]], use="complete.obs"),3)
  corr_vector[[i]] = corr
  corr_grob = grobTree(textGrob(corr , x=0.1,  y=0.95, hjust=0))
  pairwise_plot[[i]] = ggplot(movie, aes_string(x=rating1, y=rating2)) +
    geom_point(color="#f37740") +
    geom_smooth() + 
    annotation_custom(corr_grob)
}
do.call(grid.arrange, c(pairwise_plot[1:15], ncol=3))
do.call(grid.arrange, c(pairwise_plot[16:30], ncol=3))
do.call(grid.arrange, c(pairwise_plot[31:45], ncol=3))

pair_matrix = cor(movie[,rating], use="complete.obs")
corrplot(pair_matrix, method="color", type="upper", 
         addCoef.col=TRUE)
```

From imdb and rotten tomatoes 10 columns, scatterplots are created for each pair of the rating metrics (45 pairs of columns). Since there's many pairs of rating variables, a correlation matrix plot is also displayed to summarize the correlations between each pair of ratings.

There's 26 pairs of ratings trend that have positive relationship with correlation coefficient > 0.2:
```{r, warning=FALSE, echo=FALSE}
x = data.frame(t(rating_comb))
x$Correlation = corr_vector
x = x[order(-x$Correlation),]
row.names(x) = NULL
kable(x[x$Correlation>0.2,])
```

There are 14 pairs of ratings that have insignificant relationship with absoluate value of correlation coefficient < 0.2:
```{r, warning=FALSE, echo=FALSE}
kable(x[(x$Correlation<=0.2 & x$Correlation>=-0.2),])
```

There are 5 pairs of ratings that have negative correlations with the correlation coefficient < -0.2 
```{r, warning=FALSE, echo=FALSE, }
kable(x[x$Correlation< -0.2,])
```

**Q**: Comment on the similarities and differences between the user ratings of IMDb and the critics ratings of Rotten Tomatoes.

**A**: There is a negative correlation between imdb rating and tomato rotten, with correlation coefficient -0.25, implying the likely of more bad reviews in tomato meter rating is asscoiated with bad imdb rating. There is high correlation between imdb rating and tomato meter, tomato rating, tomato user meter, and tomato user rating, with correlaiton coefficient > 0.8. Implying the likely of monotonic relationship between imdb user rating and rotten tomato rating. Therefore, ratings among each imdb or rotten tomato are highly correlated. 

## 8. Ratings and awards

These ratings typically reflect the general appeal of the movie to the public or gather opinions from a larger body of critics. Whereas awards are given by professional societies that may evaluate a movie on specific attributes, such as artistic performance, screenplay, sound design, etc.

#Investigate the relationship between ratings and wins 
# TODO: Show how ratings and awards are related
```{r, warning=FALSE, echo=FALSE}

Rating = c("imdbRating","tomatoRating")
awardRating = NULL

for (i in 1:length(Rating)){
  rating = Rating[i]
  corr_rating_award_win = round(cor(movie[[rating]], movie$Wins, use="complete.obs"),3)
  corr_rating_award_grob_win = grobTree(textGrob(corr_rating_award_win , x=0.1,  y=0.95, hjust=0))
  awardRating[[i]] = ggplot(movie, aes_string(rating, y="Wins")) +
    geom_point(color="red") + 
    geom_smooth(color="blue") +
    annotation_custom(corr_rating_award_grob_win) +
    labs(x=rating,
         y="Number of Wins")
  
}
do.call(grid.arrange, c(awardRating, ncol=2))

```

#Investigate the relationship between ratings and nominations
```{r,warning=FALSE, echo=FALSE}
awardRating2 = NULL
for (i in 1:length(Rating)){
  rating = Rating[i]
  corr_rating_award_nominate = round(cor(movie[[rating]], movie$Nominations, use="complete.obs"),3)
  corr_rating_award_grob_nominate = grobTree(textGrob(corr_rating_award_nominate , x=0.1,  y=0.95, hjust=0))
  awardRating2[[i]] = ggplot(movie, aes_string(rating, y="Nominations")) +
    geom_point(color="orange") + 
    geom_smooth(color="blue") +
    annotation_custom(corr_rating_award_grob_nominate) +
    labs(x=rating, y="Number of Nominations")
}

do.call(grid.arrange,c(awardRating2,ncol=2))

```

**Q**: How good are these ratings in terms of predicting the success of a movie in winning awards or nominations? Is there a high correlation between two variables?

**A**: Both rating systems showed a positive correation between the success of a movie in winning awards. Higher rating may be a index of predicting the success of winning awards or nominations. Yet the variation of awards increases as rating increases to 7.5 and decreases after. Movies that either win awards or got nominated have around median rating grade of 7.5 in both rating systems. There are some extreme movies with very high ratings but with less number/zero awards. Compare the two rating systems, the Rotten Tomatoes system achieve stronger positive relationship than IMDB Rating system.

## 9. Expected insights

Come up with two new insights (backed up by data and graphs) that is expected. Here ???new??? means insights that are not an immediate consequence of one of the above tasks. You may use any of the columns already explored above or a different one in the dataset, such as `Title`, `Actors`, etc.

#First expected insights: 
#The relationship between gross revenue and movie duration
```{r,warning=FALSE, echo=FALSE}
#subset movie data without missing value in Gross Revenue
data9 = movie[!is.na(movie$Gross),]
corr_duration_gross = round(cor(data9[["Gross"]], data9$Runtime, use="complete.obs"),3)
corr_duration_gross_grob = grobTree(textGrob(corr_duration_gross , x=0.1,  y=0.95, hjust=0))
#plot
grossRun = ggplot(data9, aes_string(x="Runtime", y="Gross")) +
    geom_point(color="orange") + 
    geom_smooth(color="blue") +
    annotation_custom(corr_duration_gross_grob) +
    labs(x="Movie Duration",
         y="Gross Revenue")
plot(grossRun)

```

It's also interesting to see the relationship between runtime and gross revenue after removing runtime outliers
```{r,warning=FALSE, echo=FALSE}
#remove runtime outlier
data9<-data9[!is.na(data9$Runtime),]

data_outlierRemove <- subset(data9,!(data9$Runtime > quantile(data9$Runtime, probs=c(.01, .99))[2] | data9$Runtime < quantile(data9$Runtime, probs=c(.01, .91))[1])) 

corr_duration_gross_out = round(cor(data_outlierRemove[["Gross"]], data_outlierRemove$Runtime, use="complete.obs"),3)
corr_duration_gross_grob_out = grobTree(textGrob(corr_duration_gross_out , x=0.1,  y=0.95, hjust=0))
#plot
grossRun_out = ggplot(data_outlierRemove, aes_string(x="Runtime", y="Gross")) +
    geom_point(color="orange") + 
    geom_smooth(color="blue") +
    annotation_custom(corr_duration_gross_grob_out) +
    labs(x="Movie Duration",
         y="Gross Revenue")
plot(grossRun_out)
```


**Q**: Expected insight #1.

**A**: There is not much significant association between movie runtime and gross revenue, although there is a weak positive correlation (r = 0.26) between movie runtime and gross revenue after the duraiton excceed 125 minutes, and after gross revenue decreases when the duration excceed 175 minutes.  Noted that the correlation coefficient barely change after removal of runtime outliers (r = 0.27 & r = 0.28). There are some movies received very high gross revenue on the average duraiton and movies received very low gross revenue with long duration. Increases in movie duration does not strongly associate with increases in gross revenue.    

#Inspect relationship between Rotten Tomato reviews and top 10 genres
```{r,warning=FALSE, echo=FALSE}
genre = summary_gen$genre
rateGenre = NULL
for (g in genre[1:10]){
  # Filter dataset to include 1 if genre present in the record
  data = movie[movie[[paste("Genre_",g,sep="")]]==1,]
  data = data[,c("Title","tomatoReviews")]
  data$genre = g
  rateGenre = rbind(rateGenre, data)
}

rateGenre = merge(rateGenre, summary_gen[,c("genre","rank")], by="genre")

ggplot(rateGenre, aes(x=reorder(genre, -rank), y=tomatoReviews)) + 
  geom_boxplot() +
  coord_flip() +
  labs(x="Genre", y="Rotten Tomato Reviews", 
       title="Rotten Tomato Reviews in top 10 Genre")

```


**Q**: Expected insight #2.

**A**: It's interesting to investigate whether there is significant positive coreelation between the popularity of movie genre and Rotten Tomato reviews. The most common genre is Drama, yet its number of reviews is not highest in the top 10 most common genres. Instead, advanture movies and mystery movies have highest number of reviews. Therefore, the result demonstrates that there is no significant association between the popularity of movie genre and Rotten Tomato reviews.


## 10. Unexpected insight

Come up with one new insight (backed up by data and graphs) that is unexpected at first glance and do your best to motivate it. Same instructions apply as the previous task.

Previous questions showed that Rotten Tomatoes have higher positive relationship between awards compared to IMDB, it would be intereting to investigate the relationship between Rotten Tomatoes and Gross Revenue
```{r,warning=FALSE, echo=FALSE}
#calculate coreelation coefficient between Gross and tomato Rating
corr_rating_gross = round(cor(data9[["Gross"]], data9$tomatoRating, use="complete.obs"),3)
corr_rating_gross_grob = grobTree(textGrob(corr_rating_gross , x=0.1,  y=0.95, hjust=0))
#plot
grossRating = ggplot(data9, aes_string(x="tomatoRating", y="Gross")) +
    geom_point(color="orange") + 
    geom_smooth(color="blue") +
    annotation_custom(corr_rating_gross_grob) +
    labs(x="Rotten Tomatoes rating",
         y="Gross Revenue")
plot(grossRating)
```

#Investigation after removing Gross outliers
```{r,warning=FALSE, echo=FALSE}

#data without gross outliers
data10 = subset(data9,!(Gross > quantile(Gross, probs=c(.01, .99))[2] | Gross < quantile(Gross, probs=c(.01, .91))[1])) 
  
corr_rating_gross_out = round(cor(data10[["Gross"]], data10$tomatoRating, use="complete.obs"),3)
corr_rating_gross_grob_out = grobTree(textGrob(corr_rating_gross_out , x=0.1,  y=0.95, hjust=0))
grossRating_out = ggplot(data10, aes_string(x="tomatoRating", y="Gross")) +
    geom_point(color="orange") + 
    geom_smooth(color="blue") +
    annotation_custom(corr_rating_gross_grob_out) +
    labs(x="Rotten Tomatoes rating",
         y="Gross Revenue")
plot(grossRating_out)
```

**Q**: Unexpected insight.

**A**: Although the result shows that there is a slightly positive linear relationship between Rotten Tomatoes rating system and Gross Revenue. Yet the value of correlation coefficient is relatively low and hard to demonstrate a statistical significancy. On average, each rating grade has large variation in gross revenue. Good Rotten Tomatoes rating does not garantee high gross revenue and hard to make a good prediction on gross revenue. There are still other factors to be considered to predict gross revenue.
